//@version=4
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/

// Standart Deviation created by Karl Pearson
// SuperTrend created by Olivier Seban
// VIDYA and CMO created by Tushar S. Chande
// Author: Kıvanç Özbilgiç - @kivancozbilgic
// Author and Strategy: Tuğrul Kaşıkcı - @tugrulkasikci

// Inputs
strategy(title="PMax Std V", shorttitle="PMax Std V", overlay=true, currency="USD", initial_capital=1000, commission_value=0.04, default_qty_type=strategy.percent_of_equity, default_qty_value=100, margin_long=1.35, margin_short=1.35)
src = input(hl2, title="Source", group="PMAX")
Periods = input(title="ST Dev Length", type=input.integer, step=10, defval=40, group="PMAX")
Multiplier = input(title="ST Dev Multiplier", type=input.float, step=0.5, defval=3, group="PMAX")
mav = input(title="Moving Average Type", defval="VAR", options=["VAR"], group="PMAX")
length =input(18, "Moving Average Length", minval=1, group="PMAX")
showsupport = input(title="Show Moving Average?", type=input.bool, defval=true, group="PMAX")
showsignalsk = input(title="Show Crossing Signals?", type=input.bool, defval=true, group="PMAX")

// CMO and VIDYA
Var_Func(src,length)=>
    valpha=2/(length+1)
    vud1=src>src[1] ? src-src[1] : 0
    vdd1=src<src[1] ? src[1]-src : 0
    vUD=sum(vud1,9)
    vDD=sum(vdd1,9)
    vCMO=nz((vUD-vDD)/(vUD+vDD))
    VAR=0.0
    VAR:=nz(valpha*abs(vCMO)*src)+(1-valpha*abs(vCMO))*nz(VAR[1])
VAR=Var_Func(src,length)

getMA(src, length) =>
    ma = 0.0
    if mav == "VAR"
        ma := VAR
        ma
    ma
MAvg=getMA(src, length)

// Standart Deviation
stdev = stdev(hl2, Periods)

// PMax
Pmax_Func(src,length)=>
    longStop = MAvg - Multiplier*stdev
    longStopPrev = nz(longStop[1], longStop)
    longStop := MAvg > longStopPrev ? max(longStop, longStopPrev) : longStop
    shortStop = MAvg + Multiplier*stdev
    shortStopPrev = nz(shortStop[1], shortStop)
    shortStop := MAvg < shortStopPrev ? min(shortStop, shortStopPrev) : shortStop
    dir = 1
    dir := nz(dir[1], dir)
    dir := dir == -1 and MAvg > shortStopPrev ? 1 : dir == 1 and MAvg < longStopPrev ? -1 : dir
    PMax = dir==1 ? longStop: shortStop
PMax=Pmax_Func(src,length)

// Draw chart
plot(showsupport ? MAvg : na, color=color.rgb(33, 150, 243, 0), linewidth=2, title="Moving Avg Line")
pALL=plot(PMax, color=color.rgb(255, 82, 82, 0), linewidth=2, title="PMax")

// Signal conditions
buySignalk = crossover(MAvg, PMax)
plotshape(buySignalk and showsignalsk ? PMax*0.995 : na, title="Buy", text="Buy", location=location.absolute, style=shape.labelup, size=size.tiny, color=color.rgb(76, 175, 80, 0), textcolor=color.rgb(255, 255, 255, 0))
sellSignalk = crossunder(MAvg, PMax)
plotshape(sellSignalk and showsignalsk ? PMax*1.005 : na, title="Sell", text="Sell", location=location.absolute, style=shape.labeldown, size=size.tiny, color=color.rgb(255, 82, 82, 0), textcolor=color.rgb(255, 255, 255, 0))
mPlot = plot(ohlc4, title="", style=plot.style_circles, linewidth=0,display=display.none)

// VI
vortex_period = input(144, title="Vortex Length", minval=2, group="VORTEX")
VMP = sum( abs( high - low[1]), vortex_period )
VMM = sum( abs( low - high[1]), vortex_period )
STR = sum( atr(1), vortex_period )
VIP = VMP / STR
VIM = VMM / STR
vortex_long = VIP > VIM
vortex_short = VIM > VIP

// Backtest time range
FromDay    = input(defval = 12, title = "From Day", minval = 1, maxval = 31, group="BACKTEST TIME RANGE")
FromMonth  = input(defval = 7, title = "From Month", minval = 1, maxval = 12, group="BACKTEST TIME RANGE")
FromYear   = input(defval = 2021, title = "From Year", minval = 2005, group="BACKTEST TIME RANGE")
ToDay      = input(defval = 1, title = "To Day", minval = 1, maxval = 31, group="BACKTEST TIME RANGE")
ToMonth    = input(defval = 1, title = "To Month", minval = 1, maxval = 12, group="BACKTEST TIME RANGE")
ToYear     = input(defval = 9999, title = "To Year", minval = 2006, group="BACKTEST TIME RANGE")
Start     = timestamp(FromYear, FromMonth, FromDay, 00, 00)
Finish    = timestamp(ToYear, ToMonth, ToDay, 23, 59)
Timerange() =>
    time >= Start and time <= Finish ? true : false

// Max Losing Streak Protection
max_losing_streak = input(title="Max Losing Streak", type=input.integer, defval=7, minval=1, group="STRATEGY STOP LOSS")
new_loss = (strategy.losstrades > strategy.losstrades[1]) and (strategy.wintrades == strategy.wintrades[1]) and (strategy.eventrades == strategy.eventrades[1])
streak_len = 0

streak_len := if (new_loss)
    nz(streak_len[1]) + 1
else
    if (strategy.wintrades > strategy.wintrades[1]) or (strategy.eventrades > strategy.eventrades[1])
        0
    else
        nz(streak_len[1])

ok_to_trade = streak_len < max_losing_streak

// Alert message inputs - UI alert message example = Bot {{exchange}} exhange {{ticker}} pairs {{timenow}} time {{close}} USDT {{strategy.order.alert_message}}
message_long_entry  = input(title = "Long Alert Message", defval="Long Alert Message", group="ALERT MESSAGES")
message_long_close   = input(title = "Close Long Alert Message", defval="Close Long Alert Message", group="ALERT MESSAGES")
message_short_entry = input(title = "Short Alert Message", defval="Short Alert Message", group="ALERT MESSAGES")
message_short_close  = input(title = "Close Short Alert Message", defval="Close Short Alert Message", group="ALERT MESSAGES")
message_mayna = input(title = "Strategy Stop Message", defval="Strategy Stop Message", group="ALERT MESSAGES")

// Max Drawdown Protection
max_drawdown = input(title="Max Drawdown %", type=input.integer, defval=33, minval=1, group="STRATEGY STOP LOSS")
strategy.risk.max_drawdown(value=max_drawdown, type=strategy.percent_of_equity, alert_message = message_mayna)

// Entry orders
if (ok_to_trade and vortex_long and (buySignalk and PMax*0.995))
    strategy.entry(id="LONG", long=true, when=Timerange(), alert_message = message_long_entry)

if (ok_to_trade and vortex_short and (sellSignalk and PMax*1.005))
    strategy.entry(id="SHORT", long=false, when=Timerange(), alert_message = message_short_entry)
    
// Close orders
strategy.close(id="LONG", when=(sellSignalk and PMax*1.005), alert_message = message_long_close)
strategy.close(id="SHORT", when=(buySignalk and PMax*0.995), alert_message = message_short_close)

// Mayna
if (not ok_to_trade)
    strategy.close_all(alert_message = message_mayna)