//@version=4
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/

// Kalman Filter created by Rudolf Kalman
// Zero Lag EMA created by John Ehlers and Ric Way
// DEMA and TEMA created by Patrick G. Mulloy
// VIDYA and CMO created by Tushar S. Chande
// VORTEX created by Etienne Botes and Douglas Siepman
// OTT created by  Anıl Özekşi - @Anil_Ozeksi
// Author: Kıvanç Özbilgiç - @kivancozbilgic
// Author and Strategy: Tuğrul Kaşıkcı - @tugrulkasikci

// Inputs
strategy(title="Optimized Trend Tracker Vortex Kalman v4", shorttitle="OTT-V Kalman v4", overlay=true, currency="USD", initial_capital=1000, commission_value=0.04, default_qty_type=strategy.percent_of_equity, default_qty_value=100, margin_long=1.35, margin_short=1.35)
src_input = input(close, title="Source", group="OTT")
length=input(40, "OTT Period", minval=1, group="OTT")
percent=input(1.25, "OTT Percent", type=input.float, step=0.25, minval=0.25, group="OTT")
mav = input(title="Moving Average Type", defval="VAR", options=["VAR","E2PSSF", "E2PSSFV2", "E3PSSF", "E2PBF", "E2PBFV2", "E3PBF", "E3PBFV2"], group="OTT")
enable_kalman_filter = input("ON", title="Kalman Filter", type=input.string, options=["ON", "OFF"], group="KALMAN FILTER")
showsupport = input(title="Show Support Line?", type=input.bool, defval=true, group="OTT")
showsignalsk = input(title="Show Support Line Crossing Signals?", type=input.bool, defval=true, group="OTT")

// Kalman Filter
f_kalman_filter(src) =>
    float value1= na
    float value2 = na
    value1 := 0.2 * (src - src[1]) + 0.8 * nz(value1[1])
    value2 := 0.1 * (tr) + 0.8 * nz(value2[1])
    lambda = abs(value1 / value2)
    alpha = (-pow(lambda, 2) + sqrt(pow(lambda, 4) + 16 * pow(lambda, 2)))/8
    
    value3 = float(na)
    value3 := alpha * src + (1 - alpha) * nz(value3[1])
    
src = enable_kalman_filter == "ON"? f_kalman_filter(src_input): src_input

// CMO and VIDYA
Var_Func(src,length)=>
    valpha=2/(length+1)
    vud1=src>src[1] ? src-src[1] : 0
    vdd1=src<src[1] ? src[1]-src : 0
    vUD=sum(vud1,9)
    vDD=sum(vdd1,9)
    vCMO=nz((vUD-vDD)/(vUD+vDD))
    VAR=0.0
    VAR:=nz(valpha*abs(vCMO)*src)+(1-valpha*abs(vCMO))*nz(VAR[1])
VAR=Var_Func(src,length)

// Ehlers 2 Pole Super Smoother Filter V1
E2PSSF_Func(src,length)=>
    pi = 2 * asin(1)
    a1 = exp(-1.414 * pi / length)
    b1 = 2 * a1 * cos(1.414 * pi / length)
    coef2 = b1
    coef3 = -a1 * a1
    coef1 = 1 - coef2 - coef3
    ssf = 0.0
    ssf := bar_index < 3 ? src : (coef1 * src) + (coef2 * nz(ssf[1])) + (coef3 * nz(ssf[2]))
E2PSSF=E2PSSF_Func(src,length)


// Ehlers 2 Pole Super Smoother Filter V2
E2PSSFV2_Func(src,length)=>
    pi = 2 * asin(1)
    a = exp(-1.414 * pi / length)
    b = 2 * a * cos(1.414 * pi / length)
    c2 = b
    c3 = -a * a
    c1 = 1 - c2 - c3
    ssf = 0.0
    ssf := (c1 * ((src + nz(src[1])) / 2)) + (c2 * nz(ssf[1])) + (c3 * nz(ssf[2]))
E2PSSFV2=E2PSSFV2_Func(src,length)

// Ehlers 3 Pole Super Smoother Filter
E3PSSF_Func(src,length)=>
    pi = 2 * asin(1)
    a1 = exp(-pi / length)
    b1 = 2 * a1 * cos(1.738 * pi / length)
    c1 = a1 * a1
    coef2 = b1 + c1
    coef3 = -(c1 + (b1 * c1))
    coef4 = c1 * c1
    coef1 = 1 - coef2 - coef3 - coef4
    ssf = 0.0
    ssf := bar_index < 4 ? src : (coef1 * src) + (coef2 * nz(ssf[1])) + (coef3 * nz(ssf[2])) + (coef4 * nz(ssf[3]))
E3PSSF=E3PSSF_Func(src,length)

// Ehlers 2 Pole Butterworth Filter V1
E2PBF_Func(src,length)=>
    pi = 2 * asin(1)
    a = exp(-1.414 * pi / length)
    b = 2 * a * cos(1.414 * pi / length)
    c2 = b
    c3 = -a * a
    c1 = (1 - b + pow(a, 2)) / 4
    bf = 0.0
    bf := bar_index < 3 ? src : (c1 * (src + (2 * nz(src[1])) + nz(src[2]))) + (c2 * nz(bf[1])) + (c3 * nz(bf[2]))
E2PBF=E2PBF_Func(src,length)

// Ehlers 2 Pole Butterworth Filter V2
E2PBFV2_Func(src,length)=>
    pi = 2 * asin(1)
    a = exp(-1.414 * pi / length)
    b = 2 * a * cos(1.414 * 1.25 * pi / length)
    c2 = b
    c3 = -a * a
    c1 = 1 - c2 - c3
    bf = 0.0
    bf := (c1 * src) + (c2 * nz(bf[1])) + (c3 * nz(bf[2]))
E2PBFV2=E2PBFV2_Func(src,length)

// Ehlers 3 Pole Butterworth Filter
E3PBF_Func(src,length)=>
    pi = 2 * asin(1)
    a = exp(-pi / length)
    b = 2 * a * cos(1.738 * pi / length)
    c = a * a
    d2 = b + c
    d3 = -(c + (b * c))
    d4 = c * c
    d1 = 1 - d2 - d3 - d4
    bf = 0.0
    bf := (d1 * src) + (d2 * nz(bf[1])) + (d3 * nz(bf[2])) + (d4 * nz(bf[3]))
E3PBF=E3PBF_Func(src,length)

// Ehlers 3 Pole Butterworth Filter V2
E3PBFV2_Func(src,length)=>
    pi = 2 * asin(1)
    a1 = exp(-pi / length)
    b1 = 2 * a1 * cos(1.738 * pi / length)
    c1 = a1 * a1
    coef2 = b1 + c1
    coef3 = -(c1 + (b1 * c1))
    coef4 = c1 * c1
    coef1 = (1 - b1 + c1) * (1 - c1) / 8
    bf = 0.0
    bf := bar_index < 4 ? src : (coef1 * (src + (3 * nz(src[1])) + (3 * nz(src[2])) + nz(src[3]))) + (coef2 * nz(bf[1])) + (coef3 * nz(bf[2])) + (coef4 * nz(bf[3]))
E3PBFV2=E3PBFV2_Func(src,length)

getMA(src, length) =>
    ma = 0.0
    if mav == "VAR"
        ma := VAR
        ma
    if mav == "E2PSSF"
        ma := E2PSSF
        ma
    if mav == "E2PSSFV2"
        ma := E2PSSFV2
        ma
    if mav == "E3PSSF"
        ma := E3PSSF
        ma
    if mav == "E2PBF"
        ma := E2PBF
        ma
    if mav == "E2PBFV2"
        ma := E2PBFV2
        ma
    if mav == "E3PBF"
        ma := E3PBF
        ma
    if mav == "E3PBFV2"
        ma := E3PBFV2
        ma
    ma

MAvg=getMA(src, length)

// OTT
fark=MAvg*percent*0.01
longStop = MAvg - fark
longStopPrev = nz(longStop[1], longStop)
longStop := MAvg > longStopPrev ? max(longStop, longStopPrev) : longStop
shortStop =  MAvg + fark
shortStopPrev = nz(shortStop[1], shortStop)
shortStop := MAvg < shortStopPrev ? min(shortStop, shortStopPrev) : shortStop
dir = 1
dir := nz(dir[1], dir)
dir := dir == -1 and MAvg > shortStopPrev ? 1 : dir == 1 and MAvg < longStopPrev ? -1 : dir
MT = dir==1 ? longStop: shortStop
OTT=MAvg>MT ? MT*(200+percent)/200 : MT*(200-percent)/200

// Draw chart
plot(showsupport ? MAvg : na, color=color.rgb(38, 198, 218, 0), linewidth=2, title="Support Line")
pALL=plot(nz(OTT[2]), color=color.rgb(240, 98, 146, 0), linewidth=2, title="OTT")

// Signal conditions and draw signals
buySignalk = crossover(MAvg, OTT[2])
plotshape(buySignalk and showsignalsk ? OTT*0.995 : na, title="Buy", text="Buy", location=location.absolute, style=shape.labelup, size=size.tiny, color=color.rgb(76, 175, 80, 0), textcolor=color.rgb(255, 255, 255, 0))
sellSignalk = crossunder(MAvg, OTT[2])
plotshape(sellSignalk and showsignalsk ? OTT*1.005 : na, title="Sell", text="Sell", location=location.absolute, style=shape.labeldown, size=size.tiny, color=color.rgb(255, 82, 82, 0), textcolor=color.rgb(255, 255, 255, 0))
mPlot = plot(ohlc4, title="", style=plot.style_circles, linewidth=0,display=display.none)

// VI
vortex_period = input(144, title="Vortex Length", minval=2, group="TREND FILTER")
VMP = sum( abs( high - low[1]), vortex_period )
VMM = sum( abs( low - high[1]), vortex_period )
STR = sum( atr(1), vortex_period )
VIP = VMP / STR
VIM = VMM / STR
vortex_long = VIP > VIM
vortex_short = VIM > VIP

// Backtest time range
FromDay    = input(defval = 12, title = "From Day", minval = 1, maxval = 31, group="BACKTEST TIME RANGE")
FromMonth  = input(defval = 7, title = "From Month", minval = 1, maxval = 12, group="BACKTEST TIME RANGE")
FromYear   = input(defval = 2021, title = "From Year", minval = 2005, group="BACKTEST TIME RANGE")
ToDay      = input(defval = 1, title = "To Day", minval = 1, maxval = 31, group="BACKTEST TIME RANGE")
ToMonth    = input(defval = 1, title = "To Month", minval = 1, maxval = 12, group="BACKTEST TIME RANGE")
ToYear     = input(defval = 9999, title = "To Year", minval = 2006, group="BACKTEST TIME RANGE")
Start     = timestamp(FromYear, FromMonth, FromDay, 00, 00)
Finish    = timestamp(ToYear, ToMonth, ToDay, 23, 59)
Timerange() =>
    time >= Start and time <= Finish ? true : false

// Max losing streak protection
max_losing_streak = input(title="Max Losing Streak", type=input.integer, defval=7, minval=1, group="STRATEGY STOP LOSS")
new_loss = (strategy.losstrades > strategy.losstrades[1]) and (strategy.wintrades == strategy.wintrades[1]) and (strategy.eventrades == strategy.eventrades[1])
streak_len = 0

streak_len := if (new_loss)
    nz(streak_len[1]) + 1
else
    if (strategy.wintrades > strategy.wintrades[1]) or (strategy.eventrades > strategy.eventrades[1])
        0
    else
        nz(streak_len[1])

ok_to_trade = streak_len < max_losing_streak

// Alert message inputs - UI alert message example = Bot {{exchange}} exhange {{ticker}} pairs {{timenow}} time {{close}} USDT {{strategy.order.alert_message}}
message_long_entry  = input(title = "Long Alert Message", defval="Long Alert Message", group="ALERT MESSAGES")
message_long_close   = input(title = "Close Long Alert Message", defval="Close Long Alert Message", group="ALERT MESSAGES")
message_short_entry = input(title = "Short Alert Message", defval="Short Alert Message", group="ALERT MESSAGES")
message_short_close  = input(title = "Close Short Alert Message", defval="Close Short Alert Message", group="ALERT MESSAGES")
message_mayna = input(title = "Strategy Stop Message", defval="Strategy Stop Message", group="ALERT MESSAGES")

// Max drawdown protection
max_drawdown = input(title="Max Drawdown %", type=input.integer, defval=33, minval=1, group="STRATEGY STOP LOSS")
strategy.risk.max_drawdown(value=max_drawdown, type=strategy.percent_of_equity, alert_message = message_mayna)

// Entry orders
if ok_to_trade and vortex_long and (buySignalk and OTT*0.995)
    strategy.entry(id="LONG", long=true, when=Timerange(), alert_message = message_long_entry)

if ok_to_trade and vortex_short and (sellSignalk and OTT*1.005)
    strategy.entry(id="SHORT", long=false, when=Timerange(), alert_message = message_short_entry)
    
// Close orders
strategy.close(id="LONG", when=sellSignalk and OTT*1.005, alert_message = message_long_close)
strategy.close(id="SHORT", when=buySignalk and OTT*0.995, alert_message = message_short_close)

// Mayna
if (not ok_to_trade)
    strategy.close_all(alert_message = message_mayna)